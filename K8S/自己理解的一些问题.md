##### ReplicationController 和 Pod

> *ReplicationController* 确保在任何时间上运行 pod 的 “replicas” 数为定义的数量。换句话说，一个 ReplicationController 确保一个 pod 或同类的 pod 的集合总是运行和可用的。

RC 可以确保 Pod 在运行，例如使用 `kubectl delete pod <pod-name>` 删除 pod，如果使用 RC 控制器管理的 Pod， 则 RC 会重新起一个 Pod，以达到定义中期待的数目。第二，如果一个节点（NODE）出现问题，RC 也会将 Pod 调度到另一个可用节点。第三，确保 Pod 健康，如果 Pod 无法提供正常服务时，RC也会杀死不健康的Pod，重新创建。第四，滚动升级。

RC 使用 `kubectl rolling-update` 滚动升级。

---

##### ReplicationController 和 ReplicaSet[^1]

> [`ReplicaSet`](https://k8smeetup.github.io/docs/concepts/workloads/controllers/replicaset/) 是下一代 ReplicationController ，支持新的 [set-based label selector](https://k8smeetup.github.io/docs/user-guide/labels/#set-based-requirement)。

ReplicationController 标签选择器（lable selector）只支持“基于等式”，即 `environment = production,
tier != frontend` 

ReplicaSet 标签选择器支持“基于集合”，即

```yaml
environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
```

---

##### Kubernetes 核心组件

1. etcd：保存了集群的所有信息，使用 json 格式储存，只有 ApiServer 可以与它通信，查询或修改值。
2. apiserver：提供 HTTP REST API 接口（资源操作）、认证、授权、访问控制、API 注册和发现等功能。其他组件都通过其进行通信。
3. controller manager（控制器）：维护集群的状态，~~如故障检测，pod 扩展，滚动更新等~~，有很多种类型控制器。控制系统向定义的状态变化，如达到特定的 `replica`。
4. scheduler（调度器）：资源的调度，按调度的策略将 Pod 调度到节点上。
5. kubelet：第一：向 API Server 注册节点，第二：向 API Server 报告 Pod 状态、资源信息，第三：处理 API Server 下发的任务（Pod 运行等）
6. kube-proxy：提供服务发现和负载均衡。映射 service 和 endpoint，将请求按照算法转发到 pod 上。

----

##### 创建 Pod 流程

``` sequence
title: 创建 pod 流程
participant kubectl
participant apiserver
participant etcd
participant scheduler
participant kubelet
participant docker

kubectl->apiserver: create pod
apiserver-->kubectl
apiserver->etcd: write
etcd-->apiserver
apiserver->scheduler: watch(new pod)
scheduler->apiserver: bind pod
apiserver->etcd: write
etcd-->apiserver
apiserver->kubelet: watch(bound pod)
kubelet->docker: docker run
docker-->kubelet
kubelet->apiserver: udpate pod status
apiserver->etcd: write
etcd-->apiserver
apiserver-->kubelet
```

kubectl –> api server –> etcd –> schedule –> kubelet –> docker

---

##### RBAC 授权[^2]

###### Role 和 ClusterRole

角色（Role）和集群角色（ClusterRole）：可以在规则内（Rule）中授权操作（Verb）各种资源（Resource）。比如读取、检查 Pod 的权限。

```yaml
...
rules: 
  # "" 代表核心 API 组
  - apiGroups: [""]
  	resources: ["pod"]
  	verbs: ["get", "list", "watch"]
```

Role 是定义在命名空间（Namespace）内，而 ClusterRole 是定义在集群范围内（Cluster）。因此 **Role 只能在特定的命名空间内访问**，而 **ClusterRole 可以访问一些集群特定的内容**，比如集群内的资源（比如 Node），非资源端点（no-resource endpoints，比如 /healthz），所有命名空间内的资源。

###### RoleBinding 和 ClusterRoleBinding

一个或一组用户（Subject：User，Group，Service Account）通过和 Role 或 ClusterRole 绑定，获取相应的权限。

角色绑定（RoleBinding）：只能绑定同一个命名空间内的 Role。

集群角色绑定（ClusterRoleBinding）：绑定后，权限范围为整个集群。

###### Resource

主要的资源：Pod，Node，Service，Deployment，Replicaset，Statefulset，Namespace，Secret，ConfigMap。

部分资源存在子资源，如 Pod 的子资源就有 Log。

```bash
GET /api/v1/namespaces/{namespace}/pods/{name}/log
```

###### Subject

包括用户（User），组（Group），服务账号（Service Account）。

`system：…` ：为 Kubernetes 系统使用。

```yaml
...
subjects:
- kind:User
  name:"alice@example.com"
  apiGroup:rbac.authorization.k8s.io
  
---
...
subjects:
- kind:ServiceAccount
  name:default
  namespace:kube-system
# 注意 apiGroup 和 namespace
```

```bash
# 所有服务账户
system:serviceaccounts
# test 命名空间内的所有服务账户
system:serviceaccounts:test
# 所有认证的用户
system:autherticated
# 所有未认证的用户
system:unauthenticated
```



> 1. [^1]:[Labels 和 Selectors](https://k8smeetup.github.io/docs/concepts/overview/working-with-objects/labels/)
>
> 2. [^2]:[Kubernetes-基于RBAC的授权](https://juejin.im/entry/5b23280ce51d4558cd2acdea)

